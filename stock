#!/usr/bin/env python3
################################################################################
#
# stocks - monitor the stock-market right from the Unix terminal!
#
# March 2014, Forhad Ahmed
# Updated December 2024 - Python 3, scrolling, add/remove/search
#
################################################################################

from urllib.request import Request, urlopen
import sys
import os
import time
import signal
import curses
import calendar
import json
import threading
from datetime import datetime
from pathlib import Path

os.environ.setdefault('ESCDELAY', '25')

SETTINGS_FILE = Path.home() / '.stocks'
CACHE_FILE = Path.home() / '.stocks_cache'
USER_AGENT = 'Mozilla/5.0'

# Chart cache TTL in seconds per period index (0=1D no cache)
CHART_CACHE_TTL = [0, 300, 300, 600, 3600, 7200]

def is_exit_key(ch):
    return ch == 27 or ch == ord('q') or ch == ord('Q')

def is_enter_key(ch):
    return ch == 10 or ch == curses.KEY_ENTER

def is_market_open():
    gmt = time.mktime(datetime.now().utctimetuple()) + delta
    est = gmt + 3600 * (-5)
    now_et = datetime.fromtimestamp(est)
    return (now_et.weekday() < 5
            and ((now_et.hour == 9 and now_et.minute >= 30)
                 or (10 <= now_et.hour < 16)))

def in_watchlist(symbol):
    return symbol.upper() in [s.upper() for s in stocks]

def make_request(url):
    req = Request(url)
    req.add_header('User-Agent', USER_AGENT)
    return req

def get_change_color(value, selected):
    if selected:
        return curses.A_REVERSE
    return curses.color_pair(COLOR_GREEN) if value >= 0 else curses.color_pair(COLOR_RED)

def load_settings():
    global stocks, visible_columns, sort_column, sort_mode
    if not SETTINGS_FILE.exists():
        return
    try:
        with open(SETTINGS_FILE) as f:
            data = json.load(f)
            stocks = data.get('stocks', [])
            visible_columns = data.get('columns', visible_columns)
            sort_column = data.get('sort_column', 0)
            sort_mode = data.get('sort_mode', 0)
    except Exception:
        pass

def save_settings():
    try:
        data = {'stocks': stocks, 'columns': visible_columns,
                'sort_column': sort_column, 'sort_mode': sort_mode}
        with open(SETTINGS_FILE, 'w') as f:
            json.dump(data, f, indent=2)
    except Exception:
        pass

chart_cache = {}

def load_cache():
    global chart_cache
    if not CACHE_FILE.exists():
        return
    try:
        with open(CACHE_FILE) as f:
            chart_cache = json.load(f)
    except Exception:
        chart_cache = {}

def save_cache():
    try:
        with open(CACHE_FILE, 'w') as f:
            json.dump(chart_cache, f)
    except Exception:
        pass

def get_cached_chart(symbol, period_idx):
    key = f"{symbol}:{period_idx}"
    if key not in chart_cache:
        return None
    entry = chart_cache[key]
    ttl = CHART_CACHE_TTL[period_idx]
    if ttl == 0:
        return None
    if time.time() - entry.get('ts', 0) > ttl:
        return None
    return entry.get('data', [])

def set_cached_chart(symbol, period_idx, data):
    if CHART_CACHE_TTL[period_idx] == 0:
        return
    key = f"{symbol}:{period_idx}"
    chart_cache[key] = {'ts': time.time(), 'data': data}
    save_cache()

################################################################################
# Yahoo Finance API
################################################################################

def fetch_stock_data(symbols):
    if not symbols:
        return {}
    result = {}
    for sym in symbols:
        try:
            url = f'https://query1.finance.yahoo.com/v8/finance/chart/{sym.upper()}?interval=1d&range=1d'
            resp = urlopen(make_request(url), timeout=10)
            data = json.loads(resp.read().decode('utf-8'))
            chart = data.get('chart', {}).get('result', [{}])[0]
            meta = chart.get('meta', {})
            indicators = chart.get('indicators', {}).get('quote', [{}])[0]
            price = meta.get('regularMarketPrice', 0) or 0
            prev_close = meta.get('chartPreviousClose', price) or price
            change = price - prev_close if price and prev_close else 0
            change_pct = (change / prev_close * 100) if prev_close else 0
            open_prices = indicators.get('open', [])
            open_price = open_prices[-1] if open_prices and open_prices[-1] else prev_close
            result[sym] = {
                'symbol': sym.upper(),
                'name': meta.get('shortName', sym.upper()),
                'price': price,
                'change': change,
                'change_pct': change_pct,
                'prev_close': prev_close,
                'open': open_price or 0,
                'day_low': meta.get('regularMarketDayLow', 0) or 0,
                'day_high': meta.get('regularMarketDayHigh', 0) or 0,
                'volume': meta.get('regularMarketVolume', 0) or 0,
                'week52_low': meta.get('fiftyTwoWeekLow', 0) or 0,
                'week52_high': meta.get('fiftyTwoWeekHigh', 0) or 0,
            }
        except Exception:
            result[sym] = None
    return result

################################################################################
# Global state
################################################################################

win = None
COLOR_RED = None
COLOR_GREEN = None
COLOR_CYAN = None

stocks = []
stdata = {}
scroll_offset = 0
stock_index = 0
sort_column = 0
sort_mode = 0  # 0=none, 1=asc, 2=desc

INPUT_NONE = 0
INPUT_SEARCH = 1
INPUT_DELETE_CONFIRM = 2
input_mode = INPUT_NONE
input_buffer = ""

search_results = []
search_index = 0

SORT_NONE = 0
SORT_UP = 1
SORT_DOWN = 2

ALL_COLUMNS = [
    ('symbol',      'Symbol',    12),
    ('price',       'Price',     12),
    ('change',      'Change',    12),
    ('change_pct',  'Chg %',     10),
    ('day_low',     'Low',       12),
    ('day_high',    'High',      12),
    ('open',        'Open',      12),
    ('prev_close',  'PrevCls',   12),
    ('volume',      'Volume',    14),
    ('week52_low',  '52W Lo',    12),
    ('week52_high', '52W Hi',    12),
]

visible_columns = ['symbol', 'price', 'change', 'change_pct', 'volume']

settings_mode = False
settings_index = 0

chart_mode = False
chart_symbol = ""
chart_data = []
chart_period = 0
chart_cursor = -1

initial_load = True
load_start_time = 0
SPINNER = ['⠋', '⠙', '⠹', '⠸', '⠼', '⠴', '⠦', '⠧', '⠇', '⠏']

CHART_PERIODS = [
    ('1d', '5m', '1D'),
    ('5d', '15m', '5D'),
    ('1mo', '1h', '1M'),
    ('3mo', '1d', '3M'),
    ('1y', '1d', '1Y'),
    ('5y', '1wk', '5Y'),
]

delta = 0

################################################################################
# Curses / Signal handling
################################################################################

def cleanup(sig, fr):
    global win
    if win:
        try:
            win.keypad(0)
            curses.nocbreak()
            curses.echo()
            curses.endwin()
        except Exception:
            pass
    print("[quit]")
    sys.exit()

signal.signal(signal.SIGINT, cleanup)

def init_curses():
    global win, COLOR_RED, COLOR_GREEN, COLOR_CYAN
    win = curses.initscr()
    curses.noecho()
    curses.halfdelay(1)
    win.keypad(1)
    curses.start_color()
    curses.use_default_colors()
    curses.init_pair(1, curses.COLOR_RED, -1)
    curses.init_pair(2, curses.COLOR_GREEN, -1)
    curses.init_pair(3, curses.COLOR_CYAN, -1)
    COLOR_RED, COLOR_GREEN, COLOR_CYAN = 1, 2, 3
    try:
        curses.curs_set(0)
    except Exception:
        pass

def calibrate_delta():
    global delta
    try:
        resp = urlopen('http://www.google.com', timeout=5)
        tm = resp.headers.get('date', '')
        if not tm:
            return
        ts_str = tm.strip()
        if ts_str.endswith('GMT'):
            ts_str = ts_str[:-3].strip()
        if ',' in ts_str:
            ts_str = ts_str.split(',', 1)[1].strip()
        ts = datetime.strptime(ts_str, '%d %b %Y %H:%M:%S')
        ts = calendar.timegm(ts.utctimetuple())
        ct = calendar.timegm(datetime.now().utctimetuple())
        delta = ts - ct
    except Exception:
        delta = 0

################################################################################
# Data functions
################################################################################

def add_stock(symbol):
    global stocks
    sym = symbol.strip().upper()
    if sym and not in_watchlist(sym):
        stocks.append(sym)
        save_settings()
        return True
    return False

def remove_stock(index):
    global stocks, stock_index
    if 0 <= index < len(stocks):
        sym = stocks[index]
        stocks.pop(index)
        if sym in stdata:
            del stdata[sym]
        if stock_index >= len(stocks):
            stock_index = max(0, len(stocks) - 1)
        save_settings()
        return True
    return False

SEARCH_ALIASES = {
    'sp500': '^GSPC', 's&p500': '^GSPC', 's&p': '^GSPC', 'spx': '^GSPC',
    'dow': '^DJI', 'djia': '^DJI', 'dowjones': '^DJI',
    'nasdaq': '^IXIC', 'ndaq': '^IXIC', 'compx': '^IXIC',
    'russell': '^RUT', 'rut': '^RUT', 'russell2000': '^RUT',
    'vix': '^VIX', 'volatility': '^VIX',
    'gold': 'GC=F', 'silver': 'SI=F', 'oil': 'CL=F', 'crude': 'CL=F',
    'btc': 'BTC-USD', 'bitcoin': 'BTC-USD', 'eth': 'ETH-USD', 'ethereum': 'ETH-USD',
    'eur': 'EURUSD=X', 'eurusd': 'EURUSD=X', 'gbp': 'GBPUSD=X', 'usdjpy': 'JPY=X',
}

def search_stocks(query):
    if not query:
        return []
    q_lower = query.strip().lower().replace(' ', '')
    if q_lower in SEARCH_ALIASES:
        query = SEARCH_ALIASES[q_lower]
    try:
        url = f'https://query1.finance.yahoo.com/v1/finance/search?q={query}&quotesCount=10&newsCount=0'
        resp = urlopen(make_request(url), timeout=10)
        data = json.loads(resp.read().decode('utf-8'))
        results = []
        for quote in data.get('quotes', []):
            qtype = quote.get('quoteType', '')
            if qtype in ('EQUITY', 'ETF', 'MUTUALFUND', 'INDEX', 'FUTURE', 'CURRENCY', 'CRYPTOCURRENCY'):
                results.append({
                    'symbol': quote.get('symbol', ''),
                    'name': quote.get('shortname') or quote.get('longname', ''),
                    'exchange': quote.get('exchange', ''),
                    'type': qtype,
                })
        return results
    except Exception:
        return []

def get_visible_columns():
    return [(k, h, w) for k, h, w in ALL_COLUMNS if k in visible_columns]

def get_sorted_stocks():
    if sort_mode == SORT_NONE:
        return stocks
    cols = get_visible_columns()
    if sort_column >= len(cols):
        return stocks
    sort_key = cols[sort_column][0]

    def get_key(sym):
        if sort_key == 'symbol':
            return sym
        info = stdata.get(sym)
        if not info:
            return 0
        return info.get(sort_key, 0)

    return sorted(stocks, key=get_key, reverse=(sort_mode == SORT_DOWN))

################################################################################
# Chart data and rendering
################################################################################

def fetch_chart_data(symbol, period_idx=0):
    cached = get_cached_chart(symbol, period_idx)
    if cached:
        return cached
    try:
        rng, interval, _ = CHART_PERIODS[period_idx]
        url = f'https://query1.finance.yahoo.com/v8/finance/chart/{symbol}?interval={interval}&range={rng}'
        resp = urlopen(make_request(url), timeout=10)
        data = json.loads(resp.read().decode('utf-8'))
        chart = data.get('chart', {}).get('result', [{}])[0]
        timestamps = chart.get('timestamp', [])
        quotes = chart.get('indicators', {}).get('quote', [{}])[0]
        closes = quotes.get('close', [])
        prices = [(t, p) for t, p in zip(timestamps, closes) if p is not None]
        set_cached_chart(symbol, period_idx, prices)
        return prices
    except Exception:
        return []

def start_chart_fetch(symbol, period_idx):
    """Start async fetch of chart data."""
    def fetch():
        global chart_data
        chart_data = fetch_chart_data(symbol, period_idx)
    threading.Thread(target=fetch, daemon=True).start()

BRAILLE_BASE = 0x2800
BRAILLE_DOTS = [
    [0x01, 0x02, 0x04, 0x40],
    [0x08, 0x10, 0x20, 0x80],
]

def set_braille_dot(grid, width, height, gx, gy):
    char_x, char_y = gx // 2, gy // 4
    if 0 <= char_x < width and 0 <= char_y < height:
        grid[char_y][char_x] |= BRAILLE_DOTS[gx % 2][gy % 4]

def draw_braille_line(grid, width, height, x0, y0, x1, y1):
    dx, dy = abs(x1 - x0), abs(y1 - y0)
    sx = 1 if x0 < x1 else -1
    sy = 1 if y0 < y1 else -1
    err = dx - dy
    while True:
        set_braille_dot(grid, width, height, x0, y0)
        if x0 == x1 and y0 == y1:
            break
        e2 = 2 * err
        if e2 > -dy:
            err -= dy
            x0 += sx
        if e2 < dx:
            err += dx
            y0 += sy

def render_braille_chart(prices, width, height):
    if not prices or width < 1 or height < 1:
        return [], 0, 0
    vals = [p for _, p in prices]
    pmin, pmax = min(vals), max(vals)
    prange = pmax - pmin if pmax > pmin else 1
    grid_w = width * 2
    grid_h = height * 4
    if grid_h > grid_w:
        grid_h = grid_w
        height = max(1, grid_h // 4)
    grid = [[0] * width for _ in range(height)]
    grid_h = height * 4
    n = len(vals)
    points = []
    for i, price in enumerate(vals):
        gx = int(i * (grid_w - 1) / (n - 1)) if n > 1 else 0
        gy = int((pmax - price) / prange * (grid_h - 1)) if prange > 0 else grid_h // 2
        gy = max(0, min(grid_h - 1, gy))
        points.append((gx, gy))
    for i in range(len(points) - 1):
        x0, y0 = points[i]
        x1, y1 = points[i + 1]
        draw_braille_line(grid, width, height, x0, y0, x1, y1)
    rows = [''.join(chr(BRAILLE_BASE + cell) for cell in row) for row in grid]
    return rows, pmin, pmax

def get_price_levels(pmin, pmax, num_lines):
    if pmax <= pmin:
        return [pmin]
    step = (pmax - pmin) / (num_lines + 1)
    return [pmin + step * (i + 1) for i in range(num_lines)]

def format_chart_time(ts, period_idx):
    dt = datetime.fromtimestamp(ts)
    if period_idx <= 1:
        return dt.strftime('%H:%M')
    elif period_idx <= 3:
        return dt.strftime('%b %d')
    else:
        return dt.strftime('%b %y')

################################################################################
# Display functions
################################################################################

def print_header(win):
    h, w = win.getmaxyx()
    gmt = time.mktime(datetime.now().utctimetuple()) + delta
    est = gmt + 3600 * (-5)
    tss = datetime.fromtimestamp(est).strftime('%a %b %d, %Y - %I:%M:%S%p')
    try:
        win.addstr(0, 1, f"{tss} EST")
        win.addstr(0, len(tss) + 6, "- US markets ")
        if is_market_open():
            win.addstr("open", curses.color_pair(COLOR_GREEN))
        else:
            win.addstr("closed", curses.color_pair(COLOR_RED))
        count_str = f"  [{len(stocks)} stocks]"
        win.addstr(0, w - len(count_str) - 1, count_str)
    except curses.error:
        pass

def print_columns(win):
    try:
        h, w = win.getmaxyx()
        y, x = 2, 1
        cols = get_visible_columns()
        for i, (key, header, width) in enumerate(cols):
            if i == sort_column and sort_mode != SORT_NONE:
                header = header + ("▲" if sort_mode == SORT_UP else "▼")
            win.addstr(y, x, header.ljust(width - 1), curses.A_BOLD)
            x += width
        win.addstr(y + 1, 1, "─" * (w - 2), curses.A_DIM)
    except curses.error:
        pass

def print_search_results(win):
    if not search_results:
        return
    h, w = win.getmaxyx()
    start_y = 4
    max_rows = min(len(search_results), h - 7)
    try:
        win.addstr(start_y, 1, f"Search Results ({len(search_results)} found)", curses.A_BOLD)
        win.addstr(start_y + 1, 1, "Symbol     Name                         Price       Change", curses.A_DIM)
        for i in range(max_rows):
            y = start_y + 2 + i
            if y >= h - 2:
                break
            result = search_results[i]
            sym = result.get('symbol', '')[:10]
            name = result.get('name', '')[:25]
            data = result.get('data')
            selected = (i == search_index)
            in_list = in_watchlist(sym)
            try:
                if selected:
                    win.addstr(y, 1, " " * (w - 2), curses.A_REVERSE)
                attr = curses.A_REVERSE if selected else 0
                win.addstr(y, 2, sym.ljust(10), attr | curses.A_BOLD)
                win.addstr(y, 13, name.ljust(26), attr)
                if data:
                    price = data.get('price', 0)
                    change = data.get('change', 0)
                    chg_str = f"+${change:.2f}" if change >= 0 else f"-${abs(change):.2f}"
                    win.addstr(y, 40, f"${price:.2f}".ljust(12), attr)
                    win.addstr(y, 52, chg_str.ljust(10), get_change_color(change, selected) | attr)
                else:
                    win.addstr(y, 40, "N/A".ljust(12), attr | curses.A_DIM)
                if in_list:
                    win.addstr(y, 65, "(added)", attr | curses.A_DIM)
            except curses.error:
                pass
    except curses.error:
        pass

def print_settings(win):
    global settings_index
    h, w = win.getmaxyx()
    start_y = 4
    try:
        win.addstr(start_y, 1, "Column Settings", curses.A_BOLD)
        win.addstr(start_y, 20, "[Up/Down] select  [Space] toggle  [Esc] close", curses.A_DIM)
        for i, (key, header, width) in enumerate(ALL_COLUMNS):
            y = start_y + 2 + i
            if y >= h - 2:
                break
            selected = (i == settings_index)
            enabled = key in visible_columns
            is_symbol = (key == 'symbol')
            try:
                if selected:
                    win.addstr(y, 1, " " * (w - 2), curses.A_REVERSE)
                attr = curses.A_REVERSE if selected else 0
                check = "[*]" if is_symbol else ("[x]" if enabled else "[ ]")
                win.addstr(y, 2, check, attr)
                win.addstr(y, 6, header.ljust(12), attr | curses.A_BOLD)
                win.addstr(y, 19, f"(width: {width})", attr | curses.A_DIM)
            except curses.error:
                pass
    except curses.error:
        pass

def print_chart_header(win, w, info, change):
    price = info.get('price', 0) if info else 0
    chg_pct = info.get('change_pct', 0) if info else 0
    chg_str = f"+${change:.2f}" if change >= 0 else f"-${abs(change):.2f}"
    pct_str = f"+{chg_pct:.2f}%" if chg_pct >= 0 else f"{chg_pct:.2f}%"
    header = f"{chart_symbol} ${price:.2f} ({chg_str}, {pct_str})"
    win.addstr(0, 1, header, curses.A_BOLD)

    n = len(chart_data)
    if chart_cursor >= 0 and chart_cursor < n:
        ts, cursor_price = chart_data[chart_cursor]
        dt = datetime.fromtimestamp(ts)
        if chart_period <= 1:
            cursor_time = dt.strftime('%H:%M ET')
        elif chart_period <= 3:
            cursor_time = dt.strftime('%b %d %H:%M')
        else:
            cursor_time = dt.strftime('%b %d, %Y')
        cursor_info = f" | {cursor_time}  ${cursor_price:.2f}"
        win.addstr(0, len(header) + 2, cursor_info, curses.A_DIM)

    x = w - sum(len(p[2]) + 2 for p in CHART_PERIODS)
    for i, p in enumerate(CHART_PERIODS):
        attr = curses.A_BOLD if i == chart_period else curses.A_DIM
        win.addstr(0, x, p[2], attr)
        x += len(p[2]) + 2

def print_chart_body(win, h, w, rows, pmin, pmax, change, chart_x, chart_y, chart_w):
    n = len(chart_data)
    cursor_chart_x = -1
    if chart_cursor >= 0 and n > 1:
        cursor_chart_x = int(chart_cursor * (chart_w - 1) / (n - 1))

    levels = get_price_levels(pmin, pmax, 3)
    prange = pmax - pmin if pmax > pmin else 1
    level_rows = set()
    for lvl in levels:
        row_y = int((pmax - lvl) / prange * (len(rows) - 1)) if prange > 0 else 0
        level_rows.add(row_y)

    for i, row in enumerate(rows):
        y = chart_y + i
        if y >= h - 2:
            break
        if i == 0:
            label = f"${pmax:.2f}"
        elif i == len(rows) - 1:
            label = f"${pmin:.2f}"
        elif i in level_rows:
            label = ""
            for lvl in levels:
                row_y = int((pmax - lvl) / prange * (len(rows) - 1))
                if row_y == i:
                    label = f"${lvl:.2f}"
                    break
        else:
            label = ""

        try:
            win.addstr(y, 1, label.rjust(10), curses.A_DIM)
            if i in level_rows:
                win.addstr(y, chart_x, "┄" * chart_w, curses.A_DIM)
            for cx, ch in enumerate(row):
                if ch != chr(BRAILLE_BASE):
                    color = curses.color_pair(COLOR_GREEN) if change >= 0 else curses.color_pair(COLOR_RED)
                    win.addstr(y, chart_x + cx, ch, color)
            if cursor_chart_x >= 0:
                win.addstr(y, chart_x + cursor_chart_x, "│", curses.A_DIM)
        except curses.error:
            pass

    # Live marker
    if is_market_open() and chart_period == 0 and chart_data:
        try:
            vals = [p for _, p in chart_data]
            last_price = vals[-1]
            last_gy = int((pmax - last_price) / prange * (len(rows) * 4 - 1)) if prange > 0 else 0
            marker_row = last_gy // 4
            marker_y = chart_y + marker_row
            marker_x = chart_x + chart_w - 1
            if 0 <= marker_row < len(rows) and marker_y < h - 2:
                color = curses.color_pair(COLOR_GREEN) if change >= 0 else curses.color_pair(COLOR_RED)
                win.addstr(marker_y, marker_x, "●", color | curses.A_BOLD)
        except curses.error:
            pass

def print_chart_axis(win, h, w, chart_x, chart_y, chart_w, num_rows):
    try:
        time_y = chart_y + num_rows
        if time_y < h - 1 and chart_data:
            timestamps = [t for t, _ in chart_data]
            n = len(timestamps)
            num_labels = min(5, chart_w // 10)
            axis_line = list("─" * chart_w)
            tick_positions = []
            for i in range(num_labels):
                screen_x = int(i * (chart_w - 1) / (num_labels - 1)) if num_labels > 1 else 0
                if 0 <= screen_x < chart_w:
                    axis_line[screen_x] = "┬"
                    tick_positions.append((i, screen_x))
            win.addstr(time_y, chart_x, "".join(axis_line), curses.A_DIM)

            cursor_chart_x = -1
            if chart_cursor >= 0 and n > 1:
                cursor_chart_x = int(chart_cursor * (chart_w - 1) / (n - 1))
            if cursor_chart_x >= 0 and 0 <= cursor_chart_x < chart_w:
                win.addstr(time_y, chart_x + cursor_chart_x, "┼", curses.A_DIM)

            if time_y + 1 < h - 1:
                for i, screen_x in tick_positions:
                    data_idx = int(i * (n - 1) / (num_labels - 1)) if num_labels > 1 else 0
                    ts = timestamps[min(data_idx, n - 1)]
                    label = format_chart_time(ts, chart_period)
                    x = chart_x + screen_x - len(label) // 2
                    if x >= chart_x and x + len(label) < w:
                        win.addstr(time_y + 1, x, label, curses.A_DIM)
    except curses.error:
        pass

def print_chart(win):
    h, w = win.getmaxyx()
    if not chart_data:
        try:
            win.addstr(h // 2, w // 2 - 5, "Loading...", curses.A_DIM)
        except curses.error:
            pass
        return

    chart_w = w - 14
    chart_h = h - 5
    chart_x = 12
    chart_y = 1

    info = stdata.get(chart_symbol, {})
    change = info.get('change', 0) if info else 0

    try:
        print_chart_header(win, w, info, change)
    except curses.error:
        pass

    rows, pmin, pmax = render_braille_chart(chart_data, chart_w, chart_h)
    if not rows:
        return

    print_chart_body(win, h, w, rows, pmin, pmax, change, chart_x, chart_y, chart_w)
    print_chart_axis(win, h, w, chart_x, chart_y, chart_w, len(rows))

def print_stocks(win):
    global scroll_offset
    h, w = win.getmaxyx()
    visible_rows = h - 5
    start_y = 4

    if chart_mode:
        print_chart(win)
        return
    if settings_mode:
        print_settings(win)
        return
    if search_results:
        print_search_results(win)
        return

    if initial_load:
        try:
            elapsed = time.time() - load_start_time
            if elapsed > 10:
                win.addstr(start_y, 1, "Connection error", curses.color_pair(COLOR_RED))
                win.addstr(start_y + 1, 1, "Check network and restart", curses.A_DIM)
            else:
                spin = SPINNER[int(elapsed * 10) % len(SPINNER)]
                win.addstr(start_y, 1, f"{spin} Loading...", curses.A_DIM)
        except curses.error:
            pass
        return

    sstocks = get_sorted_stocks()
    total = len(sstocks)

    if stock_index < scroll_offset:
        scroll_offset = stock_index
    elif stock_index >= scroll_offset + visible_rows:
        scroll_offset = stock_index - visible_rows + 1
    scroll_offset = max(0, min(scroll_offset, max(0, total - visible_rows)))

    for i in range(visible_rows):
        idx = scroll_offset + i
        y = start_y + i
        if y >= h - 2:
            break
        if idx >= total:
            continue
        sym = sstocks[idx]
        info = stdata.get(sym)
        selected = (idx == stock_index)
        try:
            if selected:
                win.addstr(y, 0, " " * (w - 1), curses.A_REVERSE)
            x = 1
            attr = curses.A_REVERSE if selected else 0
            cols = get_visible_columns()
            for key, header, width in cols:
                val_str = ""
                color = attr
                if key == 'symbol':
                    val_str = sym[:width-1]
                elif info:
                    val = info.get(key, 0)
                    if key in ('price', 'day_low', 'day_high', 'open',
                               'prev_close', 'week52_low', 'week52_high'):
                        val_str = f"${val:.2f}"
                    elif key == 'change':
                        val_str = f"+${val:.2f}" if val >= 0 else f"-${abs(val):.2f}"
                        color = get_change_color(val, selected)
                    elif key == 'change_pct':
                        val_str = f"+{val:.2f}%" if val >= 0 else f"{val:.2f}%"
                        color = get_change_color(val, selected)
                    elif key == 'volume':
                        if val >= 1e9:
                            val_str = f"{val / 1e9:.2f}B"
                        elif val >= 1e6:
                            val_str = f"{val / 1e6:.2f}M"
                        elif val >= 1e3:
                            val_str = f"{val / 1e3:.1f}K"
                        else:
                            val_str = str(int(val))
                else:
                    val_str = "-"
                win.addstr(y, x, val_str.ljust(width - 1), color | attr)
                x += width
        except curses.error:
            pass

    if total > visible_rows:
        try:
            indicator = f" [{scroll_offset + 1}-{min(scroll_offset + visible_rows, total)}/{total}]"
            win.addstr(h - 2, w - len(indicator) - 1, indicator, curses.color_pair(COLOR_CYAN))
        except curses.error:
            pass

def print_menu(win):
    h, w = win.getmaxyx()
    y = h - 1
    try:
        win.addstr(y, 0, " " * (w - 1))
        if input_mode == INPUT_DELETE_CONFIRM:
            sstocks = get_sorted_stocks()
            sym = sstocks[stock_index] if 0 <= stock_index < len(sstocks) else "?"
            win.addstr(y, 1, f"delete {sym}? [Y/n] ", curses.A_BOLD)
        elif input_mode == INPUT_SEARCH:
            win.addstr(y, 1, f"search: {input_buffer}_", curses.A_BOLD)
        elif chart_mode:
            win.addstr(y, 1, "[up/down] stock  [tab] period  [q] close", curses.color_pair(COLOR_CYAN))
        elif settings_mode:
            win.addstr(y, 1, "[up/down] select  [space] toggle  [q] close", curses.color_pair(COLOR_CYAN))
        elif search_results:
            win.addstr(y, 1, "[up/down] select  [enter] add  [q] close", curses.color_pair(COLOR_CYAN))
        else:
            win.addstr(y, 1, "[a]dd [d]el [enter] chart [tab/s] sort [c]ols [q]uit", curses.color_pair(COLOR_CYAN))
    except curses.error:
        pass

################################################################################
# Input handling
################################################################################

def handle_chart_input(ch):
    global chart_mode, chart_data, chart_cursor, chart_period, chart_symbol, stock_index
    sstocks = get_sorted_stocks()
    total = len(sstocks)

    if is_exit_key(ch):
        chart_mode = False
        chart_data = []
        chart_cursor = -1
    elif ch == 9:  # Tab
        chart_period = (chart_period + 1) % len(CHART_PERIODS)
        chart_cursor = -1
        start_chart_fetch(chart_symbol, chart_period)
    elif ch == curses.KEY_UP and stock_index > 0:
        stock_index -= 1
        chart_symbol = sstocks[stock_index]
        start_chart_fetch(chart_symbol, chart_period)
    elif ch == curses.KEY_DOWN and stock_index < total - 1:
        stock_index += 1
        chart_symbol = sstocks[stock_index]
        start_chart_fetch(chart_symbol, chart_period)
    elif ch == curses.KEY_RIGHT and chart_data:
        chart_cursor = (chart_cursor + 1) % len(chart_data)
    elif ch == curses.KEY_LEFT and chart_data:
        chart_cursor = (chart_cursor - 1) % len(chart_data)

def handle_input_mode(ch):
    global input_mode, input_buffer, search_results, search_index
    if is_exit_key(ch):
        input_mode = INPUT_NONE
        input_buffer = ""
    elif input_mode == INPUT_DELETE_CONFIRM:
        if ch == ord('y') or ch == ord('Y') or is_enter_key(ch):
            sstocks = get_sorted_stocks()
            if sstocks and 0 <= stock_index < len(sstocks):
                sym = sstocks[stock_index]
                idx = stocks.index(sym) if sym in stocks else -1
                if idx >= 0:
                    remove_stock(idx)
        input_mode = INPUT_NONE
        input_buffer = ""
    elif is_enter_key(ch):
        if input_mode == INPUT_SEARCH and input_buffer:
            words = input_buffer.strip().split()
            if len(words) > 1:
                added = sum(1 for word in words if add_stock(word))
                if added > 0:
                    trigger_fetch()
            else:
                search_results = search_stocks(input_buffer.strip())
                search_index = 0
                if search_results:
                    symbols = [r['symbol'] for r in search_results]
                    prices = fetch_stock_data(symbols)
                    for r in search_results:
                        r['data'] = prices.get(r['symbol'])
        input_mode = INPUT_NONE
        input_buffer = ""
    elif ch == curses.KEY_BACKSPACE or ch == 127 or ch == 8:
        input_buffer = input_buffer[:-1]
    elif 32 <= ch <= 126:
        input_buffer += chr(ch)

def handle_settings_input(ch):
    global settings_mode, settings_index, visible_columns
    if is_exit_key(ch):
        settings_mode = False
    elif ch == curses.KEY_UP and settings_index > 0:
        settings_index -= 1
    elif ch == curses.KEY_DOWN and settings_index < len(ALL_COLUMNS) - 1:
        settings_index += 1
    elif ch == ord(' '):
        key = ALL_COLUMNS[settings_index][0]
        if key != 'symbol':
            if key in visible_columns:
                visible_columns.remove(key)
            else:
                visible_columns.append(key)
            save_settings()

def handle_search_results_input(ch):
    global search_results, search_index
    if is_exit_key(ch):
        search_results = []
        search_index = 0
    elif ch == curses.KEY_UP and search_index > 0:
        search_index -= 1
    elif ch == curses.KEY_DOWN and search_index < len(search_results) - 1:
        search_index += 1
    elif is_enter_key(ch):
        if 0 <= search_index < len(search_results):
            sym = search_results[search_index].get('symbol', '')
            if sym and not in_watchlist(sym):
                add_stock(sym)
                trigger_fetch()

def handle_normal_input(ch):
    global input_mode, input_buffer, stock_index, scroll_offset
    global sort_column, sort_mode, settings_mode, settings_index
    global chart_mode, chart_symbol, chart_data

    sstocks = get_sorted_stocks()
    total = len(sstocks)

    if is_exit_key(ch):
        cleanup(0, 0)
    elif ch == ord('a') or ch == ord('A') or ch == ord('/'):
        input_mode = INPUT_SEARCH
        input_buffer = ""
    elif ch == ord('d') or ch == ord('D'):
        if sstocks and 0 <= stock_index < len(sstocks):
            input_mode = INPUT_DELETE_CONFIRM
            input_buffer = ""
    elif ch == 9:  # Tab
        cols = get_visible_columns()
        if sort_mode == SORT_NONE:
            sort_mode = SORT_UP
        sort_column = (sort_column + 1) % len(cols)
        save_settings()
    elif ch == ord('c') or ch == ord('C'):
        settings_mode = True
        settings_index = 0
    elif ch == ord('s') or ch == ord('S'):
        sort_mode = (sort_mode + 1) % 3
        save_settings()
    elif ch == curses.KEY_UP and stock_index > 0:
        stock_index -= 1
    elif ch == curses.KEY_DOWN and stock_index < total - 1:
        stock_index += 1
    elif ch == curses.KEY_PPAGE:
        stock_index = max(0, stock_index - 10)
    elif ch == curses.KEY_NPAGE:
        stock_index = min(total - 1, stock_index + 10) if total > 0 else 0
    elif ch == curses.KEY_HOME:
        stock_index = 0
        scroll_offset = 0
    elif ch == curses.KEY_END:
        stock_index = max(0, total - 1)
    elif is_enter_key(ch):
        if sstocks and 0 <= stock_index < len(sstocks):
            chart_symbol = sstocks[stock_index]
            chart_data = []
            chart_mode = True
            start_chart_fetch(chart_symbol, chart_period)

def handle_input(ch):
    if chart_mode:
        handle_chart_input(ch)
        return True
    if input_mode != INPUT_NONE:
        handle_input_mode(ch)
        return True
    if settings_mode:
        handle_settings_input(ch)
        return True
    if search_results:
        handle_search_results_input(ch)
        return True
    handle_normal_input(ch)
    return False

################################################################################
# Main loop
################################################################################

fetch_lock = threading.Lock()
fetch_trigger = threading.Event()

def fetch_worker():
    global initial_load
    while True:
        fetch_trigger.wait()
        fetch_trigger.clear()
        if not stocks:
            continue
        data = fetch_stock_data(stocks)
        with fetch_lock:
            for sym in stocks:
                info = data.get(sym)
                if info:
                    stdata[sym] = info
                elif sym not in stdata:
                    stdata[sym] = None
        initial_load = False
        time.sleep(2)

def trigger_fetch():
    fetch_trigger.set()

def update(win):
    win.erase()
    if not chart_mode:
        print_header(win)
        print_columns(win)
    print_stocks(win)
    print_menu(win)
    win.refresh()

################################################################################
# Main
################################################################################

def main():
    global win, stocks, load_start_time

    calibrate_delta()
    load_settings()
    load_cache()

    if len(sys.argv) > 1:
        stocks = [s.upper() for s in sys.argv[1:]]
        save_settings()

    if not stocks:
        print("Usage: stock [symbol1] [symbol2] ...")
        print("Example: stock aapl goog msft")
        print("Stocks are saved to ~/.stocks for persistence")
        sys.exit(1)

    init_curses()

    load_start_time = time.time()
    threading.Thread(target=fetch_worker, daemon=True).start()
    trigger_fetch()

    last_fetch = time.time()

    try:
        while True:
            ch = win.getch()
            if ch > 0:
                handle_input(ch)
            if time.time() - last_fetch > 2:
                trigger_fetch()
                last_fetch = time.time()
            update(win)
    finally:
        cleanup(0, 0)

if __name__ == "__main__":
    main()
